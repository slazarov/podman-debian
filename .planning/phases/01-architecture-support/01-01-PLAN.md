---
phase: 01-architecture-support
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [config.sh.example, functions.sh]
autonomous: true
requirements: [ARCH-01, ARCH-05]

must_haves:
  truths:
    - "User can see architecture detected at startup"
    - "ARCH variable is exported and available to all scripts"
    - "Vendor-specific variables (GOARCH, PROTOC_ARCH, RUSTUP_ARCH) map correctly from ARCH"
  artifacts:
    - path: "config.sh.example"
      provides: "Centralized architecture configuration"
      exports: ["ARCH", "GOARCH", "PROTOC_ARCH", "RUSTUP_ARCH"]
      min_lines: 30
    - path: "functions.sh"
      provides: "Architecture detection function"
      contains: "detect_architecture()"
  key_links:
    - from: "config.sh.example"
      to: "functions.sh"
      via: "source and function call"
      pattern: "detect_architecture"
---

<objective>
Add centralized architecture detection and vendor-specific variable mapping to config.sh.example.

Purpose: Establish a single source of truth for architecture detection that all toolchain installers can consume. This enables ARM64 support without modifying individual installer logic.

Output: Updated config.sh.example with ARCH detection and vendor mappings, detect_architecture() function in functions.sh.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-architecture-support/01-RESEARCH.md

<interfaces>
<!-- Key interfaces from existing codebase that executors need -->

From config.sh.example (current):
```bash
export BUILD_ROOT="${toolpath}/build"
export GO_ROOT_FOLDER="/opt/go"
export GOVERSION="1.23.3"
export GOTAG="go${GOVERSION}"
export GOPATH="/opt/go/${GOVERSION}/bin"
export GOROOT="/opt/go/${GOVERSION}"
export PROTOC_VERSION="33.1"
export PROTOC_TAG="v${PROTOC_VERSION}"
export PROTOC_ROOT_FOLDER="/opt/protoc"
export PROTOC_PATH="${PROTOC_ROOT_FOLDER}/${PROTOC_VERSION}/bin/protoc"
```

From functions.sh (current exports):
```bash
# No architecture-related exports currently
# Contains: get_latest_tag(), git_clone_update(), git_checkout(), log_component(), remove_if_user_installed()
```

Architecture mapping (from RESEARCH.md):
| System Arch | Go Download | Protoc Download | Rust rustup |
|-------------|-------------|-----------------|-------------|
| x86_64/amd64 | `amd64` | `x86_64` | `x86_64-unknown-linux-gnu` |
| aarch64/ARM64 | `arm64` | `aarch_64` | `aarch64-unknown-linux-gnu` |
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add detect_architecture() function to functions.sh</name>
  <files>functions.sh</files>
  <action>
Add the `detect_architecture()` function to functions.sh after the toolpath detection block (around line 6).

The function must:
1. Use `uname -m` to detect system architecture (NOT dpkg --print-architecture - more portable)
2. Map `x86_64` to `amd64`
3. Map both `aarch64` and `arm64` to `arm64` (Linux returns aarch64, some systems return arm64)
4. Exit with error code 1 and clear message for unsupported architectures
5. Output the mapped architecture string (amd64 or arm64)

Implementation from RESEARCH.md:
```bash
detect_architecture() {
    local arch
    arch=$(uname -m)

    case "$arch" in
        x86_64)
            echo "amd64"
            ;;
        aarch64|arm64)
            echo "arm64"
            ;;
        *)
            echo "ERROR: Unsupported architecture: $arch" >&2
            echo "Supported: x86_64 (amd64), aarch64/arm64 (ARM64)" >&2
            exit 1
            ;;
    esac
}
```

Do NOT call this function yet - just define it. config.sh.example will call it.
  </action>
  <verify>
    <automated>grep -q "detect_architecture()" /Users/slazarov/Documents/Scripts/Python/zhipu-projects/podman-debian/functions.sh && echo "PASS: function defined" || echo "FAIL: function missing"</automated>
  </verify>
  <done>detect_architecture() function exists in functions.sh with correct mapping for x86_64, aarch64, and arm64</done>
</task>

<task type="auto">
  <name>Task 2: Add architecture detection and vendor mappings to config.sh.example</name>
  <files>config.sh.example</files>
  <action>
Add architecture detection and vendor-specific variable mappings to config.sh.example. Insert after the toolpath detection block (around line 6) and BEFORE the BUILD_ROOT export.

The config must:
1. Call detect_architecture() from functions.sh (source functions.sh first if not already sourced)
2. Export ARCH with default to auto-detected value, but allow environment override: `ARCH="${ARCH:-$(detect_architecture)}"`
3. Export GOARCH="$ARCH" (Go uses: amd64, arm64)
4. Export PROTOC_ARCH based on case statement (Protoc uses: x86_64, aarch_64)
5. Export RUSTUP_ARCH based on case statement (Rust uses: x86_64-unknown-linux-gnu, aarch64-unknown-linux-gnu)
6. Print detected architecture info for user visibility

Implementation from RESEARCH.md:
```bash
# Source functions first (add after toolpath detection if not present)
source "${toolpath}/functions.sh"

# ============================================
# Architecture Detection
# ============================================

# Allow override via environment variable, otherwise detect
export ARCH="${ARCH:-$(detect_architecture)}"

# Map to vendor-specific architecture strings
export GOARCH="$ARCH"  # Go uses: amd64, arm64

case "$ARCH" in
    amd64)
        export PROTOC_ARCH="x86_64"
        export RUSTUP_ARCH="x86_64-unknown-linux-gnu"
        ;;
    arm64)
        export PROTOC_ARCH="aarch_64"
        export RUSTUP_ARCH="aarch64-unknown-linux-gnu"
        ;;
esac

echo "Architecture: ${ARCH} (Go: ${GOARCH}, Protoc: ${PROTOC_ARCH}, Rust: ${RUSTUP_ARCH})"
```

IMPORTANT: The `source "${toolpath}/functions.sh"` line must be added before the architecture detection block if functions.sh is not already sourced in config.sh.example.
  </action>
  <verify>
    <automated>grep -q "export ARCH=" /Users/slazarov/Documents/Scripts/Python/zhipu-projects/podman-debian/config.sh.example && grep -q "export GOARCH=" /Users/slazarov/Documents/Scripts/Python/zhipu-projects/podman-debian/config.sh.example && grep -q "export PROTOC_ARCH=" /Users/slazarov/Documents/Scripts/Python/zhipu-projects/podman-debian/config.sh.example && grep -q "export RUSTUP_ARCH=" /Users/slazarov/Documents/Scripts/Python/zhipu-projects/podman-debian/config.sh.example && echo "PASS: all architecture variables exported" || echo "FAIL: missing architecture variables"</automated>
  </verify>
  <done>config.sh.example exports ARCH, GOARCH, PROTOC_ARCH, RUSTUP_ARCH with correct mappings; functions.sh sourced; architecture info printed</done>
</task>

</tasks>

<verification>
After completion:
1. Source config.sh.example and verify ARCH is set to either amd64 or arm64 based on current system
2. Verify GOARCH matches ARCH
3. Verify PROTOC_ARCH is x86_64 on amd64 systems, aarch_64 on arm64 systems
4. Verify RUSTUP_ARCH has correct target triple format
</verification>

<success_criteria>
- [ ] detect_architecture() function defined in functions.sh
- [ ] ARCH variable exported in config.sh.example with auto-detection
- [ ] GOARCH, PROTOC_ARCH, RUSTUP_ARCH exported with correct vendor mappings
- [ ] Environment variable override works (ARCH=arm64 ./install.sh uses arm64)
- [ ] Architecture info printed when config.sh.example is sourced
</success_criteria>

<output>
After completion, create `.planning/phases/01-architecture-support/01-01-SUMMARY.md`
</output>
