---
phase: 03-error-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - functions.sh
  - install.sh
autonomous: true
requirements: [ERRO-01, ERRO-03]
user_setup: []

must_haves:
  truths:
    - "functions.sh contains error_handler() function that outputs script name and line number"
    - "install.sh uses set -euo pipefail and exits on any error"
    - "install.sh sets error trap that calls error_handler"
  artifacts:
    - path: "functions.sh"
      provides: "Centralized error handler for all scripts"
      contains: "error_handler()"
      min_lines: 20
    - path: "install.sh"
      provides: "Main installer with strict mode and error trapping"
      contains: "set -euo pipefail"
  key_links:
    - from: "install.sh"
      to: "functions.sh"
      via: "source and trap"
      pattern: "trap 'error_handler"
---

<objective>
Add centralized error handling infrastructure to enable clear error messages across all scripts.

Purpose: Provide a reusable error_handler() function that captures script context (name, line, exit code) on failure, and enable strict mode in install.sh to catch errors immediately.

Output: functions.sh with error_handler(), install.sh with strict mode and error trap.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-error-handling/03-RESEARCH.md

<interfaces>
<!-- Key patterns from RESEARCH.md for executor reference -->

Error handler pattern (add to functions.sh):
```bash
error_handler() {
    local exit_code=$1
    local line_number=$2
    local script_name="${3##*/}"  # basename

    echo "" >&2
    echo "========================================" >&2
    echo "ERROR: Installation Failed" >&2
    echo "========================================" >&2
    echo "  Script:    ${script_name}" >&2
    echo "  Line:      ${line_number}" >&2
    echo "  Exit Code: ${exit_code}" >&2
    echo "========================================" >&2
    echo "" >&2
    echo "To debug, run: bash -x ${script_name}" >&2
    echo "" >&2

    exit "${exit_code}"
}
```

Strict mode header pattern (for install.sh):
```bash
#!/bin/bash

# Non-Interactive Mode - MUST be set before ANY apt commands
export DEBIAN_FRONTEND=noninteractive

# Strict Mode - Exit on error, undefined vars, pipe failures
set -euo pipefail

# ... after sourcing config and functions ...

# Set error trap AFTER sourcing
trap 'error_handler $? $LINENO "$BASH_SOURCE"' ERR
```

CRITICAL: Do NOT add `set -e` to config.sh or functions.sh - they are sourced files and `exit` would exit the parent shell.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add error_handler() function to functions.sh</name>
  <files>functions.sh</files>
  <action>
Add the error_handler() function to functions.sh after the existing helper functions (after remove_if_user_installed).

The function must:
1. Accept three parameters: exit_code, line_number, script_name
2. Extract basename from script_name using `${3##*/}`
3. Output a formatted error message to stderr with:
   - Visual separator (========)
   - "ERROR: Installation Failed" header
   - Script name, line number, and exit code
   - Debug hint: "To debug, run: bash -x {script_name}"
4. Exit with the provided exit_code

Place the function after the existing content, before any final comments. Add a section header comment "# ============================================" and "# Error Handling" before the function.
  </action>
  <verify>
    <automated>grep -q "error_handler()" functions.sh && grep -q "trap 'error_handler" install.sh 2>/dev/null || echo "Task 2 not yet complete"</automated>
  </verify>
  <done>functions.sh contains error_handler() function that outputs script name, line number, and exit code on failure</done>
</task>

<task type="auto">
  <name>Task 2: Enable strict mode and error trap in install.sh</name>
  <files>install.sh</files>
  <action>
Modify install.sh to enable bash strict mode and set up error trapping:

1. Replace the commented `# set -e` on line 7 with `set -euo pipefail` (uncommented)
   - The line should read exactly: `set -euo pipefail`
   - Keep the comment "# Abort on Error" above it

2. Add the error trap immediately AFTER sourcing functions.sh (after line 17):
   ```bash
   # Set error trap AFTER sourcing (config/functions may not support strict mode)
   trap 'error_handler $? $LINENO "$BASH_SOURCE"' ERR
   ```

3. The order must be:
   - DEBIAN_FRONTEND export
   - set -euo pipefail
   - toolpath setup
   - source config.sh
   - source functions.sh
   - trap statement (NEW)
   - source scripts...

DO NOT add set -e to config.sh or functions.sh - they are sourced files.
  </action>
  <verify>
    <automated>grep -q "set -euo pipefail" install.sh && grep -q "trap 'error_handler" install.sh</automated>
  </verify>
  <done>install.sh uses set -euo pipefail and sets error trap that calls error_handler with script context</done>
</task>

</tasks>

<verification>
Verify error handling foundation is in place:

1. Check error_handler exists in functions.sh:
   ```bash
   grep -A 20 "error_handler()" functions.sh | grep -q "Script:"
   ```

2. Check install.sh has strict mode:
   ```bash
   grep -q "set -euo pipefail" install.sh
   ```

3. Check install.sh has error trap:
   ```bash
   grep -q "trap 'error_handler" install.sh
   ```

4. Verify config.sh does NOT have set -e (it's a sourced file):
   ```bash
   ! grep -q "^set -e" config.sh
   ```
</verification>

<success_criteria>
- functions.sh contains error_handler() function with script name, line, and exit code output
- install.sh has uncommented `set -euo pipefail`
- install.sh has `trap 'error_handler $? $LINENO "$BASH_SOURCE"' ERR` after sourcing functions.sh
- config.sh and functions.sh do NOT have set -e (they are sourced files)
</success_criteria>

<output>
After completion, create `.planning/phases/03-error-handling/03-01-SUMMARY.md`
</output>
